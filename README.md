# Звіт: Пошук рішень з використанням алгоритму Backtracking
Над проєктом працювала команда №3: Бугір Єлизавета, Боднар Аліна, Карпіна Олеся, Дзюба Оксана


У цьому проєкті ми досліджуємо потужність алгоритму Backtracking для розв'язання класичних задач на пошук та комбінаторику. Ми реалізували декілька задач і проаналізували їх складність, ефективність порівняно з іншими методами розв'язання.

## Задачі, які ми реалізували:
> Розв'язання судоку - Боднар Аліна

> Вихід з лабіринту - Карпіна Олеся

> Кросворд - Карпіна Олеся

> Задача розфарбування графа - Дзюба Оксана

> N-Queens - Бугір Єлизавета

> Візуалізація вище перелічених задач - Боднар Аліна

## Реалізація на основі backtracking, порівняння ефективності з іншими методами, аналіз складності алгоритмів
### Розв'язання судоку
Ми протестували різні імплементації судоку через використання бектрекінгу, dfs та жадібного методу. 
#### Детальніше про методи:
* DFS (глибина у пошук) - перебирає варіанти послідовно
* Backtracking (з поверненням) - розумніше шукає рішення, повертається назад при помилках
* Greedy (жадібний) - ставить число в першу доступну клітинку, без перевірки всіх варіантів

Ми протестували алгоритми на двох розмірах дошок, стандартному 9х9 і більшому розмірі 16х16. Також ми використали різну кількість підсказок (clues), щоб порівняти, наскільки швидко кожний алгоритм справляється з дошкою в залежності від заповненості початкової дошки.
Для дошки 9х9 було дано 20, 30 і 40 підсказок. Для 16х16 - 110, 120 і 130.

Ми вивели 3 графи, щоб порівняти ефективність цих методів:
* перший покаує як змінюється час виконання усіх трьох методів залежно від розміру дошки;
* другий показує їхню роботу залежно від кількості підсказок на дошці 9х9
* третій показує їхню роботу залежно від кількості підсказок на дошці 16х16

#### Аналіз результатів
* Greedy алгоритм — найшвидший у всіх випадках:
Практично завжди працює за 0.0001 - 0.0004 секунд, незалежно від розміру або кількості підказок
Як працює:
Алгоритм заповнює порожні клітинки найпростішим способом: він бере перше можливе число, яке не порушує правила судоку в конкретному місці, і переходить до наступної клітинки. Він не перевіряє, що буде далі, і не повертається назад у разі помилки.
Чому він швидкий:
Він не перевіряє варіанти наперед, а лише перший, що підходить.
Також немає рекурсії або циклічного перебору варіантів.
ВПроте він не гарантує правильне чи унікальне рішення. Може виявитися, що подальші клітинки вже неможливо заповнити без конфліктів, але алгоритм цього не помічає.

* Backtracking — стабільний і досить швидкий:
Як працює:
Пробує вставити одне з можливих чисел у клітинку, і переходить далі. Якщо в процесі заповнення виявляється, що далі немає жодного можливого ходу, алгоритм повертається назад і пробує інше число в попередній клітинці.
Чому швидший за DFS:
Він використовує логіку для відсікання поганих рішень рано, тому не перебирає всі варіанти.
Часто розв’язує задачу дуже швидко, особливо коли підказок достатньо (тобто задача не дуже складна).
Чому повільніше за Greedy:
Використовує рекурсію та перевірки кількох варіантів, для точного та гарантовано правильного розв’язання.

* DFS — найповільніший і менш передбачуваний:
Як працює:
Пробує вставити всі можливі числа у клітинки, переходячи якнайглибше у рішенні, навіть якщо вибраний шлях веде до помилки. Він не "переосмислює" вибори до того, як дійде до кінця дерева рішень.
Чому він повільний:
Повністю перебирає всі варіанти, навіть ті, які можна було би відкинути раніше.
Погано працює з великими сітками або задачами з малою кількістю підказок (тобто високою складністю).
На приклад, у випадку з сіткою 16x16 та 120 підказками, час DFS міг зростати до 2 секунд, тоді як Backtracking розв’язував те саме завдання за менше ніж 0.1 секунди.

Можна зробити висновок, що найкраще підходить backtracking: він майже завжди швидкий, і гарантує правильне рішення, на відміну вд швидшого greedy методу
### Вихід з лабіринту

### Кросворд

### Задача розфарбування графа

### N-Queens

## Висновки: придатність алгоритму backtracking для різних класів задач.

