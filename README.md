# Звіт: Пошук рішень з використанням алгоритму Backtracking
Над проєктом працювала команда №3: Бугір Єлизавета, Боднар Аліна, Карпіна Олеся, Дзюба Оксана


У цьому проєкті ми досліджуємо потужність алгоритму Backtracking для розв'язання класичних задач на пошук та комбінаторику. Ми реалізували декілька задач і проаналізували їх складність, ефективність порівняно з іншими методами розв'язання.

## Задачі, які ми реалізували:
> Розв'язання судоку - Боднар Аліна

> Вихід з лабіринту - Карпіна Олеся

> Кросворд - Карпіна Олеся

> Задача розфарбування графа - Дзюба Оксана

> N-Queens - Бугір Єлизавета

> Візуалізація вище перелічених задач - Боднар Аліна

## Реалізація на основі backtracking, порівняння ефективності з іншими методами, аналіз складності алгоритмів
### Розв'язання судоку
Алгоритм Backtracking - це метод, який перебирає всі можливі варіанти і повертається назад, якщо вибраний шлях не веде до розв’язку.
#### Кроки:
1. У нашій реалізації він спочатку шукає першу порожню клітинку за допомогою ```find_empty_cell```. Програма шукає першу клітинку, яка ще не заповнена (0). Якщо таких немає - судоку розв’язане, і функція повертає True.
2. Спроба вставити число від 1 до 9 для знайденої порожньої клітинки: ```for num in range(1, size + 1):``` Але ми вставляємо число лише якщо воно не порушує правила судоку.

3. Перевірка правильності вставки за допомогою ```is_valid(board, row, col, num)```
Ця функція перевіряє:
* чи вже є таке число у цьому рядку
* чи є в цьому стовпці
* чи є в маленькому 3×3 квадраті

4. Рекурсивний виклик для наступної клітинки
Після вставки алгоритм знову викликає сам себе для наступної порожньої клітинки:
```if solve_backtracking(board): return True```
5. Якщо шлях неправильний — ми повертаємося назад (робимо "відкат"):
```board[row][col] = 0```

#### Візуалізація
* Консоль:
Використано модуль colorama, щоб підсвічувати клітинку, яку програма щойно заповнила:
```from colorama import init, Fore, Back, Style```
```init(autoreset=True)```
```highlight``` підсвічує зеленим фоном клітинку, яка зараз заповнюється.
Після кожного кроку робиться затримка:
```time.sleep(delay)```

* Візуалізація через Pygame:
Створюється вікно 540x540 пікселів.
Кожна клітинка малюється у прямокутнику.
Коли заповнюється нова клітинка — вона відображається зеленим кольором.
Після кожного ходу робиться пауза ```pygame.time.delay(100)``` для наочності.
Щоб запустити розв’язування або закрити вікно треба натиснути пробіл.


#### Запуск:
Запускається з терміналу командою: ```python3 sudoku.py console```.

Щоб запустити візуальну версію: ```python3 launcher.py```
### Порівняння різних методів
Ми протестували різні імплементації судоку через використання бектрекінгу, dfs та жадібного методу. 
#### Детальніше про методи:
* DFS (глибина у пошук) - перебирає варіанти послідовно
* Backtracking (з поверненням) - розумніше шукає рішення, повертається назад при помилках
* Greedy (жадібний) - ставить число в першу доступну клітинку, без перевірки всіх варіантів

Ми протестували алгоритми на двох розмірах дошок, стандартному 9х9 і більшому розмірі 16х16. Також ми використали різну кількість підсказок (clues), щоб порівняти, наскільки швидко кожний алгоритм справляється з дошкою в залежності від заповненості початкової дошки.
Для дошки 9х9 було дано 20, 30 і 40 підсказок. Для 16х16 - 110, 120 і 130.

Ми вивели 3 графи, щоб порівняти ефективність цих методів:
* перший покаує як змінюється час виконання усіх трьох методів залежно від розміру дошки;
* другий показує їхню роботу залежно від кількості підсказок на дошці 9х9
* третій показує їхню роботу залежно від кількості підсказок на дошці 16х16

#### Аналіз результатів
![Alt text](sudoku_benchmark.png)
* Greedy алгоритм — найшвидший у всіх випадках:
Обчислювальна складність:
O(N^2)
Практично завжди працює за 0.0001 - 0.0004 секунд, незалежно від розміру або кількості підказок
Як працює:
Алгоритм заповнює порожні клітинки найпростішим способом: він бере перше можливе число, яке не порушує правила судоку в конкретному місці, і переходить до наступної клітинки. Він не перевіряє, що буде далі, і не повертається назад у разі помилки.
Чому він швидкий:
Він не перевіряє варіанти наперед, а лише перший, що підходить.
Також немає рекурсії або циклічного перебору варіантів.
ВПроте він не гарантує правильне чи унікальне рішення. Може виявитися, що подальші клітинки вже неможливо заповнити без конфліктів, але алгоритм цього не помічає.

* Backtracking — стабільний і досить швидкий:
Обчислювальна складність:
O(9^M)
Як працює:
Пробує вставити одне з можливих чисел у клітинку, і переходить далі. Якщо в процесі заповнення виявляється, що далі немає жодного можливого ходу, алгоритм повертається назад і пробує інше число в попередній клітинці.
Чому швидший за DFS:
Він використовує логіку для відсікання поганих рішень рано, тому не перебирає всі варіанти.
Часто розв’язує задачу дуже швидко, особливо коли підказок достатньо (тобто задача не дуже складна).
Чому повільніше за Greedy:
Використовує рекурсію та перевірки кількох варіантів, для точного та гарантовано правильного розв’язання.

* DFS — найповільніший і менш передбачуваний:
Обчислювальна складність:
O(9^M)
Як працює:
Пробує вставити всі можливі числа у клітинки, переходячи якнайглибше у рішенні, навіть якщо вибраний шлях веде до помилки. Він не "переосмислює" вибори до того, як дійде до кінця дерева рішень.
Чому він повільний:
Повністю перебирає всі варіанти, навіть ті, які можна було би відкинути раніше.
Погано працює з великими сітками або задачами з малою кількістю підказок (тобто високою складністю).
На приклад, у випадку з сіткою 16x16 та 120 підказками, час DFS міг зростати до 2 секунд, тоді як Backtracking розв’язував те саме завдання за менше ніж 0.1 секунди.

Можна зробити висновок, що найкраще підходить backtracking: він майже завжди швидкий, і гарантує правильне рішення, на відміну вд швидшого greedy методу


### Вихід з лабіринту

### Кросворд
#### Мета: автоматично заповнити кросворд заданими словами.
#### Основні етапи:
1) Завантаження слів:

Слова беруться з файлу words_2.txt випадковим чином.

2) Початок рекурсії (```python метод solve класу BacktrackingSolver```):

Пробуємо розмістити перше слово у всіх можливих комірках по горизонталі та вертикалі.

Якщо слово підходить (```перевірка в is_valid_placement```):

Розміщуємо його на полі (```place_word```).

Малюємо поточний стан (візуально або в консолі).

Переходимо до наступного слова (```solve(index + 1)```).

Перевірка перетинів слів (```check_intersections```):

Програма перевіряє, чи утворені нові слова при перетині входять у список допустимих.

Бектрекінг:

Якщо розмістити всі слова не вдається — останнє слово видаляється (```remove_word```) і пробується інша позиція.

Цей процес повторюється до тих пір, поки не знайдеться рішення або всі варіанти не буде вичерпано.

#### Візуалізація:

Консоль:

* '.' — порожня клітинка.

* '#' — заблокована клітинка.

* '[A]' — підсвічені перетини.

* A — звичайні літери.

Pygame (графіяна візуалізація):

* Білий — порожня клітинка для заповнення ('-').

* Сірий — заповнена літера.

* Жовтий — підсвічена комірка (напр. при новій спробі розміщення слова).

* Чорний — рамки клітинок.

* Перетини слів виділяються спеціально (у консолі — в квадратних дужках [A]).

#### Як запустити та вхід/вихід програми:
* Вхід:
        Грід кросворду — список списків символів:

        '-' — порожня клітинка для слова.

        '#' — заблокована клітинка (сюди слова не ставляться).

        Грід задається прямо у коді (змінна grid).

        Слова — беруться з файлу words_2.txt (випадково вибирається,наприклад, 5 штук).

* Вихід:
        Заповнений кросворд зі словами.

        У візуальному режимі — показ процесу заповнення.

        У консольному режимі — текстовий вивід поля після кожного кроку.

        Повідомлення про успіх або неможливість знайти рішення.


Режим задаємо через командний рядок:
```python3 crossword.py console``` - консоль візуалізація

```python3 crossword.py visual``` - pygame візуалізація
#### Порівнюємо  із greedy algorythm та brute force:
Шкала часу на графіку - логарифмічна 
Порівняння роботи алгоритмів було виконано на 3 різних "дошках": 4x7, 13x7, 29x7
![crossword_comparison](https://github.com/user-attachments/assets/8d6319be-27a7-41f2-9d55-a62c24c68b2f)


Жадібний алгоритм (Greedy) є найшвидшим для всіх розмірів сіток, проте важливо зазначити, що він не завжди знаходить рішення. Наприклад, на тестових сітках алгоритм впорався лише з найменшою з них, а на інших — завершувався помилкою, не змігши заповнити сітку повністю. Це відбувається тому, що жадібний підхід завжди обирає локально оптимальний варіант, не враховуючи глобальної картини.

Повний перебір (Brute Force) та бектрекінг (Backtracking) демонструють приблизно однакову швидкість, оскільки обидва мають експоненційну складність O(p^w), де p — кількість можливих позицій для одного слова, а w — кількість слів у завданні. Однак бектрекінг, завдяки ранньому відсіченню невдалих варіантів, часто працює трохи ефективніше на практиці.

### Задача розфарбування графа

### N-Queens

## Висновки: придатність алгоритму backtracking для різних класів задач.

