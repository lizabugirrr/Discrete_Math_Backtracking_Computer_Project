# Звіт: Пошук рішень з використанням алгоритму Backtracking
Над проєктом працювала команда №3: Бугір Єлизавета, Боднар Аліна, Карпіна Олеся, Дзюба Оксана


У цьому проєкті ми досліджуємо потужність алгоритму Backtracking для розв'язання класичних задач на пошук та комбінаторику. Ми реалізували декілька задач і проаналізували їх складність, ефективність порівняно з іншими методами розв'язання.

## Задачі, які ми реалізували:
> Розв'язання судоку - Боднар Аліна

> Вихід з лабіринту - Карпіна Олеся

> Кросворд - Карпіна Олеся

> Задача розфарбування графа - Дзюба Оксана

> N-Queens - Бугір Єлизавета

> Візуалізація вище перелічених задач - Боднар Аліна

## Реалізація на основі backtracking, порівняння ефективності з іншими методами, аналіз складності алгоритмів
### Розв'язання судоку
Алгоритм Backtracking - це метод, який перебирає всі можливі варіанти і повертається назад, якщо вибраний шлях не веде до розв’язку.
Кроки:
1. У нашій реалізації він спочатку шукає першу порожню клітинку за допомогою ```find_empty_cell```. Програма шукає першу клітинку, яка ще не заповнена (0). Якщо таких немає - судоку розв’язане, і функція повертає True.
2. Спроба вставити число від 1 до 9 для знайденої порожньої клітинки: ```for num in range(1, size + 1):``` Але ми вставляємо число лише якщо воно не порушує правила судоку.

3. Перевірка правильності вставки за допомогою ```is_valid(board, row, col, num)```
Ця функція перевіряє:
* чи вже є таке число у цьому рядку
* чи є в цьому стовпці
* чи є в маленькому 3×3 квадраті

4. Рекурсивний виклик для наступної клітинки
Після вставки алгоритм знову викликає сам себе для наступної порожньої клітинки:
```if solve_backtracking(board): return True```
5. Якщо шлях неправильний — ми повертаємося назад (робимо "відкат"):
```board[row][col] = 0```

Запуск:
Запускається з терміналу командою: python3 sudoku.py console
Щоб запустити візуальну версію: python3 launcher.py
### Порівняння різних методів
Ми протестували різні імплементації судоку через використання бектрекінгу, dfs та жадібного методу. 
#### Детальніше про методи:
* DFS (глибина у пошук) - перебирає варіанти послідовно
* Backtracking (з поверненням) - розумніше шукає рішення, повертається назад при помилках
* Greedy (жадібний) - ставить число в першу доступну клітинку, без перевірки всіх варіантів

Ми протестували алгоритми на двох розмірах дошок, стандартному 9х9 і більшому розмірі 16х16. Також ми використали різну кількість підсказок (clues), щоб порівняти, наскільки швидко кожний алгоритм справляється з дошкою в залежності від заповненості початкової дошки.
Для дошки 9х9 було дано 20, 30 і 40 підсказок. Для 16х16 - 110, 120 і 130.

Ми вивели 3 графи, щоб порівняти ефективність цих методів:
* перший покаує як змінюється час виконання усіх трьох методів залежно від розміру дошки;
* другий показує їхню роботу залежно від кількості підсказок на дошці 9х9
* третій показує їхню роботу залежно від кількості підсказок на дошці 16х16

#### Аналіз результатів
* Greedy алгоритм — найшвидший у всіх випадках:
Практично завжди працює за 0.0001 - 0.0004 секунд, незалежно від розміру або кількості підказок
Як працює:
Алгоритм заповнює порожні клітинки найпростішим способом: він бере перше можливе число, яке не порушує правила судоку в конкретному місці, і переходить до наступної клітинки. Він не перевіряє, що буде далі, і не повертається назад у разі помилки.
Чому він швидкий:
Він не перевіряє варіанти наперед, а лише перший, що підходить.
Також немає рекурсії або циклічного перебору варіантів.
ВПроте він не гарантує правильне чи унікальне рішення. Може виявитися, що подальші клітинки вже неможливо заповнити без конфліктів, але алгоритм цього не помічає.

* Backtracking — стабільний і досить швидкий:
Як працює:
Пробує вставити одне з можливих чисел у клітинку, і переходить далі. Якщо в процесі заповнення виявляється, що далі немає жодного можливого ходу, алгоритм повертається назад і пробує інше число в попередній клітинці.
Чому швидший за DFS:
Він використовує логіку для відсікання поганих рішень рано, тому не перебирає всі варіанти.
Часто розв’язує задачу дуже швидко, особливо коли підказок достатньо (тобто задача не дуже складна).
Чому повільніше за Greedy:
Використовує рекурсію та перевірки кількох варіантів, для точного та гарантовано правильного розв’язання.

* DFS — найповільніший і менш передбачуваний:
Як працює:
Пробує вставити всі можливі числа у клітинки, переходячи якнайглибше у рішенні, навіть якщо вибраний шлях веде до помилки. Він не "переосмислює" вибори до того, як дійде до кінця дерева рішень.
Чому він повільний:
Повністю перебирає всі варіанти, навіть ті, які можна було би відкинути раніше.
Погано працює з великими сітками або задачами з малою кількістю підказок (тобто високою складністю).
На приклад, у випадку з сіткою 16x16 та 120 підказками, час DFS міг зростати до 2 секунд, тоді як Backtracking розв’язував те саме завдання за менше ніж 0.1 секунди.

Можна зробити висновок, що найкраще підходить backtracking: він майже завжди швидкий, і гарантує правильне рішення, на відміну вд швидшого greedy методу
### Вихід з лабіринту

### Кросворд

### Задача розфарбування графа

### N-Queens

## Висновки: придатність алгоритму backtracking для різних класів задач.

